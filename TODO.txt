"input_a.txt" -> a
"input_b.txt" -> b
"c.txt" -> space

a -> [50, relu]   # link
[60, sigmoid] <- c   # reverse_link
[70, relu]
[10, sin]

Описание:
Слой может не иметь кол-ва нейронов и функции активации - свободные члены 

Синтаксис:
- [] - Слой, свободные члены и т. д.
- word - название переменной или функции

  ?:
  - Обратное распостранение ошибки
  - Свёрточные слои
  - Создание своих функций????????????

Есть:
- Слои
- Функции активации
- Числа
- Свободные члены (?) Отдельные от слоёв вектора

TODO:
- Создать метод что-то типа get_json_data и начать писать парсер
- Нормально продумать парсер, продумать все возможные варианты использования операторов и т. д.
  Везде ли будет правильно отрабатывать
- Подумать над парсером, мб как-то изменить в стронону меней костыльности
- Провести бы рефакторинг и начать давать номральные имета, то есть более универсальные.
  Token это token, не value, word и так далее

- Для объектов, работающих с Линками нужно сделать класс, чтобы они поддерживали с ними операции. Или нет?

Метод get_json_data будет у:
- Слоёв
- Связанных операторов, но не всегда
- Импорт

Важно:
- По идеи считывать из файла будет последний модуль. Щас храним просто путь
- Компилятор создаёт СТРУКТУРУ, он не должен выполнять код, только СОЗДАТЬ структуру.
  Либо выполнять но уже после оптимизации. Возможно должен выполнять различные вычисления, типа +, - и т. д.
- По идеи словами будут либо переменные  либо названия функций


?????????????????????????????????????????????????????????????????
Node (Узел AST)
├── Statement (Оператор)
│   ├── ExpressionStatement (Оператор-выражение)
│   ├── IfStatement
│   ├── WhileStatement
│   └── ...
├── Expression (Выражение)
│   ├── BinaryExpression (a + b)
│   ├── Literal (5, "hello")
│   ├── Identifier (x)
│   └── ...
└── Declaration
    ├── VariableDeclaration
    └── FunctionDeclaration

Expression - считает
Statement - выполняет
?????????????????????????????????????????????????????????????????